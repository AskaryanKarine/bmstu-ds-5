// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package server

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	innermodels "github.com/AskaryanKarine/bmstu-ds-4/internal/reservation/models"
	"github.com/AskaryanKarine/bmstu-ds-4/pkg/models"
	"github.com/gojuno/minimock/v3"
)

// HotelStorageMock implements hotelStorage
type HotelStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAllHotels          func(ctx context.Context, pagination innermodels.PaginationParams) (ha1 []models.HotelResponse, i1 int, err error)
	funcGetAllHotelsOrigin    string
	inspectFuncGetAllHotels   func(ctx context.Context, pagination innermodels.PaginationParams)
	afterGetAllHotelsCounter  uint64
	beforeGetAllHotelsCounter uint64
	GetAllHotelsMock          mHotelStorageMockGetAllHotels

	funcGetHotelInfoByUUID          func(ctx context.Context, uuid string) (h1 models.HotelResponse, err error)
	funcGetHotelInfoByUUIDOrigin    string
	inspectFuncGetHotelInfoByUUID   func(ctx context.Context, uuid string)
	afterGetHotelInfoByUUIDCounter  uint64
	beforeGetHotelInfoByUUIDCounter uint64
	GetHotelInfoByUUIDMock          mHotelStorageMockGetHotelInfoByUUID
}

// NewHotelStorageMock returns a mock for hotelStorage
func NewHotelStorageMock(t minimock.Tester) *HotelStorageMock {
	m := &HotelStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAllHotelsMock = mHotelStorageMockGetAllHotels{mock: m}
	m.GetAllHotelsMock.callArgs = []*HotelStorageMockGetAllHotelsParams{}

	m.GetHotelInfoByUUIDMock = mHotelStorageMockGetHotelInfoByUUID{mock: m}
	m.GetHotelInfoByUUIDMock.callArgs = []*HotelStorageMockGetHotelInfoByUUIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mHotelStorageMockGetAllHotels struct {
	optional           bool
	mock               *HotelStorageMock
	defaultExpectation *HotelStorageMockGetAllHotelsExpectation
	expectations       []*HotelStorageMockGetAllHotelsExpectation

	callArgs []*HotelStorageMockGetAllHotelsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// HotelStorageMockGetAllHotelsExpectation specifies expectation struct of the hotelStorage.GetAllHotels
type HotelStorageMockGetAllHotelsExpectation struct {
	mock               *HotelStorageMock
	params             *HotelStorageMockGetAllHotelsParams
	paramPtrs          *HotelStorageMockGetAllHotelsParamPtrs
	expectationOrigins HotelStorageMockGetAllHotelsExpectationOrigins
	results            *HotelStorageMockGetAllHotelsResults
	returnOrigin       string
	Counter            uint64
}

// HotelStorageMockGetAllHotelsParams contains parameters of the hotelStorage.GetAllHotels
type HotelStorageMockGetAllHotelsParams struct {
	ctx        context.Context
	pagination innermodels.PaginationParams
}

// HotelStorageMockGetAllHotelsParamPtrs contains pointers to parameters of the hotelStorage.GetAllHotels
type HotelStorageMockGetAllHotelsParamPtrs struct {
	ctx        *context.Context
	pagination *innermodels.PaginationParams
}

// HotelStorageMockGetAllHotelsResults contains results of the hotelStorage.GetAllHotels
type HotelStorageMockGetAllHotelsResults struct {
	ha1 []models.HotelResponse
	i1  int
	err error
}

// HotelStorageMockGetAllHotelsOrigins contains origins of expectations of the hotelStorage.GetAllHotels
type HotelStorageMockGetAllHotelsExpectationOrigins struct {
	origin           string
	originCtx        string
	originPagination string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) Optional() *mHotelStorageMockGetAllHotels {
	mmGetAllHotels.optional = true
	return mmGetAllHotels
}

// Expect sets up expected params for hotelStorage.GetAllHotels
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) Expect(ctx context.Context, pagination innermodels.PaginationParams) *mHotelStorageMockGetAllHotels {
	if mmGetAllHotels.mock.funcGetAllHotels != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by Set")
	}

	if mmGetAllHotels.defaultExpectation == nil {
		mmGetAllHotels.defaultExpectation = &HotelStorageMockGetAllHotelsExpectation{}
	}

	if mmGetAllHotels.defaultExpectation.paramPtrs != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by ExpectParams functions")
	}

	mmGetAllHotels.defaultExpectation.params = &HotelStorageMockGetAllHotelsParams{ctx, pagination}
	mmGetAllHotels.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllHotels.expectations {
		if minimock.Equal(e.params, mmGetAllHotels.defaultExpectation.params) {
			mmGetAllHotels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllHotels.defaultExpectation.params)
		}
	}

	return mmGetAllHotels
}

// ExpectCtxParam1 sets up expected param ctx for hotelStorage.GetAllHotels
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) ExpectCtxParam1(ctx context.Context) *mHotelStorageMockGetAllHotels {
	if mmGetAllHotels.mock.funcGetAllHotels != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by Set")
	}

	if mmGetAllHotels.defaultExpectation == nil {
		mmGetAllHotels.defaultExpectation = &HotelStorageMockGetAllHotelsExpectation{}
	}

	if mmGetAllHotels.defaultExpectation.params != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by Expect")
	}

	if mmGetAllHotels.defaultExpectation.paramPtrs == nil {
		mmGetAllHotels.defaultExpectation.paramPtrs = &HotelStorageMockGetAllHotelsParamPtrs{}
	}
	mmGetAllHotels.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllHotels.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllHotels
}

// ExpectPaginationParam2 sets up expected param pagination for hotelStorage.GetAllHotels
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) ExpectPaginationParam2(pagination innermodels.PaginationParams) *mHotelStorageMockGetAllHotels {
	if mmGetAllHotels.mock.funcGetAllHotels != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by Set")
	}

	if mmGetAllHotels.defaultExpectation == nil {
		mmGetAllHotels.defaultExpectation = &HotelStorageMockGetAllHotelsExpectation{}
	}

	if mmGetAllHotels.defaultExpectation.params != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by Expect")
	}

	if mmGetAllHotels.defaultExpectation.paramPtrs == nil {
		mmGetAllHotels.defaultExpectation.paramPtrs = &HotelStorageMockGetAllHotelsParamPtrs{}
	}
	mmGetAllHotels.defaultExpectation.paramPtrs.pagination = &pagination
	mmGetAllHotels.defaultExpectation.expectationOrigins.originPagination = minimock.CallerInfo(1)

	return mmGetAllHotels
}

// Inspect accepts an inspector function that has same arguments as the hotelStorage.GetAllHotels
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) Inspect(f func(ctx context.Context, pagination innermodels.PaginationParams)) *mHotelStorageMockGetAllHotels {
	if mmGetAllHotels.mock.inspectFuncGetAllHotels != nil {
		mmGetAllHotels.mock.t.Fatalf("Inspect function is already set for HotelStorageMock.GetAllHotels")
	}

	mmGetAllHotels.mock.inspectFuncGetAllHotels = f

	return mmGetAllHotels
}

// Return sets up results that will be returned by hotelStorage.GetAllHotels
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) Return(ha1 []models.HotelResponse, i1 int, err error) *HotelStorageMock {
	if mmGetAllHotels.mock.funcGetAllHotels != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by Set")
	}

	if mmGetAllHotels.defaultExpectation == nil {
		mmGetAllHotels.defaultExpectation = &HotelStorageMockGetAllHotelsExpectation{mock: mmGetAllHotels.mock}
	}
	mmGetAllHotels.defaultExpectation.results = &HotelStorageMockGetAllHotelsResults{ha1, i1, err}
	mmGetAllHotels.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllHotels.mock
}

// Set uses given function f to mock the hotelStorage.GetAllHotels method
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) Set(f func(ctx context.Context, pagination innermodels.PaginationParams) (ha1 []models.HotelResponse, i1 int, err error)) *HotelStorageMock {
	if mmGetAllHotels.defaultExpectation != nil {
		mmGetAllHotels.mock.t.Fatalf("Default expectation is already set for the hotelStorage.GetAllHotels method")
	}

	if len(mmGetAllHotels.expectations) > 0 {
		mmGetAllHotels.mock.t.Fatalf("Some expectations are already set for the hotelStorage.GetAllHotels method")
	}

	mmGetAllHotels.mock.funcGetAllHotels = f
	mmGetAllHotels.mock.funcGetAllHotelsOrigin = minimock.CallerInfo(1)
	return mmGetAllHotels.mock
}

// When sets expectation for the hotelStorage.GetAllHotels which will trigger the result defined by the following
// Then helper
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) When(ctx context.Context, pagination innermodels.PaginationParams) *HotelStorageMockGetAllHotelsExpectation {
	if mmGetAllHotels.mock.funcGetAllHotels != nil {
		mmGetAllHotels.mock.t.Fatalf("HotelStorageMock.GetAllHotels mock is already set by Set")
	}

	expectation := &HotelStorageMockGetAllHotelsExpectation{
		mock:               mmGetAllHotels.mock,
		params:             &HotelStorageMockGetAllHotelsParams{ctx, pagination},
		expectationOrigins: HotelStorageMockGetAllHotelsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllHotels.expectations = append(mmGetAllHotels.expectations, expectation)
	return expectation
}

// Then sets up hotelStorage.GetAllHotels return parameters for the expectation previously defined by the When method
func (e *HotelStorageMockGetAllHotelsExpectation) Then(ha1 []models.HotelResponse, i1 int, err error) *HotelStorageMock {
	e.results = &HotelStorageMockGetAllHotelsResults{ha1, i1, err}
	return e.mock
}

// Times sets number of times hotelStorage.GetAllHotels should be invoked
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) Times(n uint64) *mHotelStorageMockGetAllHotels {
	if n == 0 {
		mmGetAllHotels.mock.t.Fatalf("Times of HotelStorageMock.GetAllHotels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllHotels.expectedInvocations, n)
	mmGetAllHotels.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllHotels
}

func (mmGetAllHotels *mHotelStorageMockGetAllHotels) invocationsDone() bool {
	if len(mmGetAllHotels.expectations) == 0 && mmGetAllHotels.defaultExpectation == nil && mmGetAllHotels.mock.funcGetAllHotels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllHotels.mock.afterGetAllHotelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllHotels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllHotels implements hotelStorage
func (mmGetAllHotels *HotelStorageMock) GetAllHotels(ctx context.Context, pagination innermodels.PaginationParams) (ha1 []models.HotelResponse, i1 int, err error) {
	mm_atomic.AddUint64(&mmGetAllHotels.beforeGetAllHotelsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllHotels.afterGetAllHotelsCounter, 1)

	mmGetAllHotels.t.Helper()

	if mmGetAllHotels.inspectFuncGetAllHotels != nil {
		mmGetAllHotels.inspectFuncGetAllHotels(ctx, pagination)
	}

	mm_params := HotelStorageMockGetAllHotelsParams{ctx, pagination}

	// Record call args
	mmGetAllHotels.GetAllHotelsMock.mutex.Lock()
	mmGetAllHotels.GetAllHotelsMock.callArgs = append(mmGetAllHotels.GetAllHotelsMock.callArgs, &mm_params)
	mmGetAllHotels.GetAllHotelsMock.mutex.Unlock()

	for _, e := range mmGetAllHotels.GetAllHotelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ha1, e.results.i1, e.results.err
		}
	}

	if mmGetAllHotels.GetAllHotelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllHotels.GetAllHotelsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllHotels.GetAllHotelsMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllHotels.GetAllHotelsMock.defaultExpectation.paramPtrs

		mm_got := HotelStorageMockGetAllHotelsParams{ctx, pagination}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllHotels.t.Errorf("HotelStorageMock.GetAllHotels got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllHotels.GetAllHotelsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pagination != nil && !minimock.Equal(*mm_want_ptrs.pagination, mm_got.pagination) {
				mmGetAllHotels.t.Errorf("HotelStorageMock.GetAllHotels got unexpected parameter pagination, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllHotels.GetAllHotelsMock.defaultExpectation.expectationOrigins.originPagination, *mm_want_ptrs.pagination, mm_got.pagination, minimock.Diff(*mm_want_ptrs.pagination, mm_got.pagination))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllHotels.t.Errorf("HotelStorageMock.GetAllHotels got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllHotels.GetAllHotelsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllHotels.GetAllHotelsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllHotels.t.Fatal("No results are set for the HotelStorageMock.GetAllHotels")
		}
		return (*mm_results).ha1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetAllHotels.funcGetAllHotels != nil {
		return mmGetAllHotels.funcGetAllHotels(ctx, pagination)
	}
	mmGetAllHotels.t.Fatalf("Unexpected call to HotelStorageMock.GetAllHotels. %v %v", ctx, pagination)
	return
}

// GetAllHotelsAfterCounter returns a count of finished HotelStorageMock.GetAllHotels invocations
func (mmGetAllHotels *HotelStorageMock) GetAllHotelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllHotels.afterGetAllHotelsCounter)
}

// GetAllHotelsBeforeCounter returns a count of HotelStorageMock.GetAllHotels invocations
func (mmGetAllHotels *HotelStorageMock) GetAllHotelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllHotels.beforeGetAllHotelsCounter)
}

// Calls returns a list of arguments used in each call to HotelStorageMock.GetAllHotels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllHotels *mHotelStorageMockGetAllHotels) Calls() []*HotelStorageMockGetAllHotelsParams {
	mmGetAllHotels.mutex.RLock()

	argCopy := make([]*HotelStorageMockGetAllHotelsParams, len(mmGetAllHotels.callArgs))
	copy(argCopy, mmGetAllHotels.callArgs)

	mmGetAllHotels.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllHotelsDone returns true if the count of the GetAllHotels invocations corresponds
// the number of defined expectations
func (m *HotelStorageMock) MinimockGetAllHotelsDone() bool {
	if m.GetAllHotelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllHotelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllHotelsMock.invocationsDone()
}

// MinimockGetAllHotelsInspect logs each unmet expectation
func (m *HotelStorageMock) MinimockGetAllHotelsInspect() {
	for _, e := range m.GetAllHotelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HotelStorageMock.GetAllHotels at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllHotelsCounter := mm_atomic.LoadUint64(&m.afterGetAllHotelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllHotelsMock.defaultExpectation != nil && afterGetAllHotelsCounter < 1 {
		if m.GetAllHotelsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to HotelStorageMock.GetAllHotels at\n%s", m.GetAllHotelsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to HotelStorageMock.GetAllHotels at\n%s with params: %#v", m.GetAllHotelsMock.defaultExpectation.expectationOrigins.origin, *m.GetAllHotelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllHotels != nil && afterGetAllHotelsCounter < 1 {
		m.t.Errorf("Expected call to HotelStorageMock.GetAllHotels at\n%s", m.funcGetAllHotelsOrigin)
	}

	if !m.GetAllHotelsMock.invocationsDone() && afterGetAllHotelsCounter > 0 {
		m.t.Errorf("Expected %d calls to HotelStorageMock.GetAllHotels at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllHotelsMock.expectedInvocations), m.GetAllHotelsMock.expectedInvocationsOrigin, afterGetAllHotelsCounter)
	}
}

type mHotelStorageMockGetHotelInfoByUUID struct {
	optional           bool
	mock               *HotelStorageMock
	defaultExpectation *HotelStorageMockGetHotelInfoByUUIDExpectation
	expectations       []*HotelStorageMockGetHotelInfoByUUIDExpectation

	callArgs []*HotelStorageMockGetHotelInfoByUUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// HotelStorageMockGetHotelInfoByUUIDExpectation specifies expectation struct of the hotelStorage.GetHotelInfoByUUID
type HotelStorageMockGetHotelInfoByUUIDExpectation struct {
	mock               *HotelStorageMock
	params             *HotelStorageMockGetHotelInfoByUUIDParams
	paramPtrs          *HotelStorageMockGetHotelInfoByUUIDParamPtrs
	expectationOrigins HotelStorageMockGetHotelInfoByUUIDExpectationOrigins
	results            *HotelStorageMockGetHotelInfoByUUIDResults
	returnOrigin       string
	Counter            uint64
}

// HotelStorageMockGetHotelInfoByUUIDParams contains parameters of the hotelStorage.GetHotelInfoByUUID
type HotelStorageMockGetHotelInfoByUUIDParams struct {
	ctx  context.Context
	uuid string
}

// HotelStorageMockGetHotelInfoByUUIDParamPtrs contains pointers to parameters of the hotelStorage.GetHotelInfoByUUID
type HotelStorageMockGetHotelInfoByUUIDParamPtrs struct {
	ctx  *context.Context
	uuid *string
}

// HotelStorageMockGetHotelInfoByUUIDResults contains results of the hotelStorage.GetHotelInfoByUUID
type HotelStorageMockGetHotelInfoByUUIDResults struct {
	h1  models.HotelResponse
	err error
}

// HotelStorageMockGetHotelInfoByUUIDOrigins contains origins of expectations of the hotelStorage.GetHotelInfoByUUID
type HotelStorageMockGetHotelInfoByUUIDExpectationOrigins struct {
	origin     string
	originCtx  string
	originUuid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) Optional() *mHotelStorageMockGetHotelInfoByUUID {
	mmGetHotelInfoByUUID.optional = true
	return mmGetHotelInfoByUUID
}

// Expect sets up expected params for hotelStorage.GetHotelInfoByUUID
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) Expect(ctx context.Context, uuid string) *mHotelStorageMockGetHotelInfoByUUID {
	if mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUID != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by Set")
	}

	if mmGetHotelInfoByUUID.defaultExpectation == nil {
		mmGetHotelInfoByUUID.defaultExpectation = &HotelStorageMockGetHotelInfoByUUIDExpectation{}
	}

	if mmGetHotelInfoByUUID.defaultExpectation.paramPtrs != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by ExpectParams functions")
	}

	mmGetHotelInfoByUUID.defaultExpectation.params = &HotelStorageMockGetHotelInfoByUUIDParams{ctx, uuid}
	mmGetHotelInfoByUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHotelInfoByUUID.expectations {
		if minimock.Equal(e.params, mmGetHotelInfoByUUID.defaultExpectation.params) {
			mmGetHotelInfoByUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHotelInfoByUUID.defaultExpectation.params)
		}
	}

	return mmGetHotelInfoByUUID
}

// ExpectCtxParam1 sets up expected param ctx for hotelStorage.GetHotelInfoByUUID
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) ExpectCtxParam1(ctx context.Context) *mHotelStorageMockGetHotelInfoByUUID {
	if mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUID != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by Set")
	}

	if mmGetHotelInfoByUUID.defaultExpectation == nil {
		mmGetHotelInfoByUUID.defaultExpectation = &HotelStorageMockGetHotelInfoByUUIDExpectation{}
	}

	if mmGetHotelInfoByUUID.defaultExpectation.params != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by Expect")
	}

	if mmGetHotelInfoByUUID.defaultExpectation.paramPtrs == nil {
		mmGetHotelInfoByUUID.defaultExpectation.paramPtrs = &HotelStorageMockGetHotelInfoByUUIDParamPtrs{}
	}
	mmGetHotelInfoByUUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetHotelInfoByUUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetHotelInfoByUUID
}

// ExpectUuidParam2 sets up expected param uuid for hotelStorage.GetHotelInfoByUUID
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) ExpectUuidParam2(uuid string) *mHotelStorageMockGetHotelInfoByUUID {
	if mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUID != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by Set")
	}

	if mmGetHotelInfoByUUID.defaultExpectation == nil {
		mmGetHotelInfoByUUID.defaultExpectation = &HotelStorageMockGetHotelInfoByUUIDExpectation{}
	}

	if mmGetHotelInfoByUUID.defaultExpectation.params != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by Expect")
	}

	if mmGetHotelInfoByUUID.defaultExpectation.paramPtrs == nil {
		mmGetHotelInfoByUUID.defaultExpectation.paramPtrs = &HotelStorageMockGetHotelInfoByUUIDParamPtrs{}
	}
	mmGetHotelInfoByUUID.defaultExpectation.paramPtrs.uuid = &uuid
	mmGetHotelInfoByUUID.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

	return mmGetHotelInfoByUUID
}

// Inspect accepts an inspector function that has same arguments as the hotelStorage.GetHotelInfoByUUID
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) Inspect(f func(ctx context.Context, uuid string)) *mHotelStorageMockGetHotelInfoByUUID {
	if mmGetHotelInfoByUUID.mock.inspectFuncGetHotelInfoByUUID != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("Inspect function is already set for HotelStorageMock.GetHotelInfoByUUID")
	}

	mmGetHotelInfoByUUID.mock.inspectFuncGetHotelInfoByUUID = f

	return mmGetHotelInfoByUUID
}

// Return sets up results that will be returned by hotelStorage.GetHotelInfoByUUID
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) Return(h1 models.HotelResponse, err error) *HotelStorageMock {
	if mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUID != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by Set")
	}

	if mmGetHotelInfoByUUID.defaultExpectation == nil {
		mmGetHotelInfoByUUID.defaultExpectation = &HotelStorageMockGetHotelInfoByUUIDExpectation{mock: mmGetHotelInfoByUUID.mock}
	}
	mmGetHotelInfoByUUID.defaultExpectation.results = &HotelStorageMockGetHotelInfoByUUIDResults{h1, err}
	mmGetHotelInfoByUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHotelInfoByUUID.mock
}

// Set uses given function f to mock the hotelStorage.GetHotelInfoByUUID method
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) Set(f func(ctx context.Context, uuid string) (h1 models.HotelResponse, err error)) *HotelStorageMock {
	if mmGetHotelInfoByUUID.defaultExpectation != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("Default expectation is already set for the hotelStorage.GetHotelInfoByUUID method")
	}

	if len(mmGetHotelInfoByUUID.expectations) > 0 {
		mmGetHotelInfoByUUID.mock.t.Fatalf("Some expectations are already set for the hotelStorage.GetHotelInfoByUUID method")
	}

	mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUID = f
	mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUIDOrigin = minimock.CallerInfo(1)
	return mmGetHotelInfoByUUID.mock
}

// When sets expectation for the hotelStorage.GetHotelInfoByUUID which will trigger the result defined by the following
// Then helper
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) When(ctx context.Context, uuid string) *HotelStorageMockGetHotelInfoByUUIDExpectation {
	if mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUID != nil {
		mmGetHotelInfoByUUID.mock.t.Fatalf("HotelStorageMock.GetHotelInfoByUUID mock is already set by Set")
	}

	expectation := &HotelStorageMockGetHotelInfoByUUIDExpectation{
		mock:               mmGetHotelInfoByUUID.mock,
		params:             &HotelStorageMockGetHotelInfoByUUIDParams{ctx, uuid},
		expectationOrigins: HotelStorageMockGetHotelInfoByUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHotelInfoByUUID.expectations = append(mmGetHotelInfoByUUID.expectations, expectation)
	return expectation
}

// Then sets up hotelStorage.GetHotelInfoByUUID return parameters for the expectation previously defined by the When method
func (e *HotelStorageMockGetHotelInfoByUUIDExpectation) Then(h1 models.HotelResponse, err error) *HotelStorageMock {
	e.results = &HotelStorageMockGetHotelInfoByUUIDResults{h1, err}
	return e.mock
}

// Times sets number of times hotelStorage.GetHotelInfoByUUID should be invoked
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) Times(n uint64) *mHotelStorageMockGetHotelInfoByUUID {
	if n == 0 {
		mmGetHotelInfoByUUID.mock.t.Fatalf("Times of HotelStorageMock.GetHotelInfoByUUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHotelInfoByUUID.expectedInvocations, n)
	mmGetHotelInfoByUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHotelInfoByUUID
}

func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) invocationsDone() bool {
	if len(mmGetHotelInfoByUUID.expectations) == 0 && mmGetHotelInfoByUUID.defaultExpectation == nil && mmGetHotelInfoByUUID.mock.funcGetHotelInfoByUUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHotelInfoByUUID.mock.afterGetHotelInfoByUUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHotelInfoByUUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHotelInfoByUUID implements hotelStorage
func (mmGetHotelInfoByUUID *HotelStorageMock) GetHotelInfoByUUID(ctx context.Context, uuid string) (h1 models.HotelResponse, err error) {
	mm_atomic.AddUint64(&mmGetHotelInfoByUUID.beforeGetHotelInfoByUUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHotelInfoByUUID.afterGetHotelInfoByUUIDCounter, 1)

	mmGetHotelInfoByUUID.t.Helper()

	if mmGetHotelInfoByUUID.inspectFuncGetHotelInfoByUUID != nil {
		mmGetHotelInfoByUUID.inspectFuncGetHotelInfoByUUID(ctx, uuid)
	}

	mm_params := HotelStorageMockGetHotelInfoByUUIDParams{ctx, uuid}

	// Record call args
	mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.mutex.Lock()
	mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.callArgs = append(mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.callArgs, &mm_params)
	mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.mutex.Unlock()

	for _, e := range mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.h1, e.results.err
		}
	}

	if mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation.paramPtrs

		mm_got := HotelStorageMockGetHotelInfoByUUIDParams{ctx, uuid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetHotelInfoByUUID.t.Errorf("HotelStorageMock.GetHotelInfoByUUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uuid != nil && !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) {
				mmGetHotelInfoByUUID.t.Errorf("HotelStorageMock.GetHotelInfoByUUID got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHotelInfoByUUID.t.Errorf("HotelStorageMock.GetHotelInfoByUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHotelInfoByUUID.GetHotelInfoByUUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHotelInfoByUUID.t.Fatal("No results are set for the HotelStorageMock.GetHotelInfoByUUID")
		}
		return (*mm_results).h1, (*mm_results).err
	}
	if mmGetHotelInfoByUUID.funcGetHotelInfoByUUID != nil {
		return mmGetHotelInfoByUUID.funcGetHotelInfoByUUID(ctx, uuid)
	}
	mmGetHotelInfoByUUID.t.Fatalf("Unexpected call to HotelStorageMock.GetHotelInfoByUUID. %v %v", ctx, uuid)
	return
}

// GetHotelInfoByUUIDAfterCounter returns a count of finished HotelStorageMock.GetHotelInfoByUUID invocations
func (mmGetHotelInfoByUUID *HotelStorageMock) GetHotelInfoByUUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHotelInfoByUUID.afterGetHotelInfoByUUIDCounter)
}

// GetHotelInfoByUUIDBeforeCounter returns a count of HotelStorageMock.GetHotelInfoByUUID invocations
func (mmGetHotelInfoByUUID *HotelStorageMock) GetHotelInfoByUUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHotelInfoByUUID.beforeGetHotelInfoByUUIDCounter)
}

// Calls returns a list of arguments used in each call to HotelStorageMock.GetHotelInfoByUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHotelInfoByUUID *mHotelStorageMockGetHotelInfoByUUID) Calls() []*HotelStorageMockGetHotelInfoByUUIDParams {
	mmGetHotelInfoByUUID.mutex.RLock()

	argCopy := make([]*HotelStorageMockGetHotelInfoByUUIDParams, len(mmGetHotelInfoByUUID.callArgs))
	copy(argCopy, mmGetHotelInfoByUUID.callArgs)

	mmGetHotelInfoByUUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetHotelInfoByUUIDDone returns true if the count of the GetHotelInfoByUUID invocations corresponds
// the number of defined expectations
func (m *HotelStorageMock) MinimockGetHotelInfoByUUIDDone() bool {
	if m.GetHotelInfoByUUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHotelInfoByUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHotelInfoByUUIDMock.invocationsDone()
}

// MinimockGetHotelInfoByUUIDInspect logs each unmet expectation
func (m *HotelStorageMock) MinimockGetHotelInfoByUUIDInspect() {
	for _, e := range m.GetHotelInfoByUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HotelStorageMock.GetHotelInfoByUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHotelInfoByUUIDCounter := mm_atomic.LoadUint64(&m.afterGetHotelInfoByUUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHotelInfoByUUIDMock.defaultExpectation != nil && afterGetHotelInfoByUUIDCounter < 1 {
		if m.GetHotelInfoByUUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to HotelStorageMock.GetHotelInfoByUUID at\n%s", m.GetHotelInfoByUUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to HotelStorageMock.GetHotelInfoByUUID at\n%s with params: %#v", m.GetHotelInfoByUUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetHotelInfoByUUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHotelInfoByUUID != nil && afterGetHotelInfoByUUIDCounter < 1 {
		m.t.Errorf("Expected call to HotelStorageMock.GetHotelInfoByUUID at\n%s", m.funcGetHotelInfoByUUIDOrigin)
	}

	if !m.GetHotelInfoByUUIDMock.invocationsDone() && afterGetHotelInfoByUUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to HotelStorageMock.GetHotelInfoByUUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHotelInfoByUUIDMock.expectedInvocations), m.GetHotelInfoByUUIDMock.expectedInvocationsOrigin, afterGetHotelInfoByUUIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HotelStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAllHotelsInspect()

			m.MinimockGetHotelInfoByUUIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HotelStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HotelStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAllHotelsDone() &&
		m.MinimockGetHotelInfoByUUIDDone()
}
