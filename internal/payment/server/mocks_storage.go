// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package server

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/AskaryanKarine/bmstu-ds-4/pkg/models"
	"github.com/gojuno/minimock/v3"
)

// PaymentStorageMock implements paymentStorage
type PaymentStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, payment models.PaymentInfo) (s1 string, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, payment models.PaymentInfo)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mPaymentStorageMockCreate

	funcDelete          func(ctx context.Context, uuid string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, uuid string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mPaymentStorageMockDelete

	funcGetPaymentInfoByUUID          func(ctx context.Context, uuid string) (p1 models.PaymentInfo, err error)
	funcGetPaymentInfoByUUIDOrigin    string
	inspectFuncGetPaymentInfoByUUID   func(ctx context.Context, uuid string)
	afterGetPaymentInfoByUUIDCounter  uint64
	beforeGetPaymentInfoByUUIDCounter uint64
	GetPaymentInfoByUUIDMock          mPaymentStorageMockGetPaymentInfoByUUID
}

// NewPaymentStorageMock returns a mock for paymentStorage
func NewPaymentStorageMock(t minimock.Tester) *PaymentStorageMock {
	m := &PaymentStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mPaymentStorageMockCreate{mock: m}
	m.CreateMock.callArgs = []*PaymentStorageMockCreateParams{}

	m.DeleteMock = mPaymentStorageMockDelete{mock: m}
	m.DeleteMock.callArgs = []*PaymentStorageMockDeleteParams{}

	m.GetPaymentInfoByUUIDMock = mPaymentStorageMockGetPaymentInfoByUUID{mock: m}
	m.GetPaymentInfoByUUIDMock.callArgs = []*PaymentStorageMockGetPaymentInfoByUUIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPaymentStorageMockCreate struct {
	optional           bool
	mock               *PaymentStorageMock
	defaultExpectation *PaymentStorageMockCreateExpectation
	expectations       []*PaymentStorageMockCreateExpectation

	callArgs []*PaymentStorageMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentStorageMockCreateExpectation specifies expectation struct of the paymentStorage.Create
type PaymentStorageMockCreateExpectation struct {
	mock               *PaymentStorageMock
	params             *PaymentStorageMockCreateParams
	paramPtrs          *PaymentStorageMockCreateParamPtrs
	expectationOrigins PaymentStorageMockCreateExpectationOrigins
	results            *PaymentStorageMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// PaymentStorageMockCreateParams contains parameters of the paymentStorage.Create
type PaymentStorageMockCreateParams struct {
	ctx     context.Context
	payment models.PaymentInfo
}

// PaymentStorageMockCreateParamPtrs contains pointers to parameters of the paymentStorage.Create
type PaymentStorageMockCreateParamPtrs struct {
	ctx     *context.Context
	payment *models.PaymentInfo
}

// PaymentStorageMockCreateResults contains results of the paymentStorage.Create
type PaymentStorageMockCreateResults struct {
	s1  string
	err error
}

// PaymentStorageMockCreateOrigins contains origins of expectations of the paymentStorage.Create
type PaymentStorageMockCreateExpectationOrigins struct {
	origin        string
	originCtx     string
	originPayment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mPaymentStorageMockCreate) Optional() *mPaymentStorageMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for paymentStorage.Create
func (mmCreate *mPaymentStorageMockCreate) Expect(ctx context.Context, payment models.PaymentInfo) *mPaymentStorageMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentStorageMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &PaymentStorageMockCreateParams{ctx, payment}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for paymentStorage.Create
func (mmCreate *mPaymentStorageMockCreate) ExpectCtxParam1(ctx context.Context) *mPaymentStorageMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentStorageMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PaymentStorageMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectPaymentParam2 sets up expected param payment for paymentStorage.Create
func (mmCreate *mPaymentStorageMockCreate) ExpectPaymentParam2(payment models.PaymentInfo) *mPaymentStorageMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentStorageMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PaymentStorageMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.payment = &payment
	mmCreate.defaultExpectation.expectationOrigins.originPayment = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the paymentStorage.Create
func (mmCreate *mPaymentStorageMockCreate) Inspect(f func(ctx context.Context, payment models.PaymentInfo)) *mPaymentStorageMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for PaymentStorageMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by paymentStorage.Create
func (mmCreate *mPaymentStorageMockCreate) Return(s1 string, err error) *PaymentStorageMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PaymentStorageMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &PaymentStorageMockCreateResults{s1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the paymentStorage.Create method
func (mmCreate *mPaymentStorageMockCreate) Set(f func(ctx context.Context, payment models.PaymentInfo) (s1 string, err error)) *PaymentStorageMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the paymentStorage.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the paymentStorage.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the paymentStorage.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mPaymentStorageMockCreate) When(ctx context.Context, payment models.PaymentInfo) *PaymentStorageMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PaymentStorageMock.Create mock is already set by Set")
	}

	expectation := &PaymentStorageMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &PaymentStorageMockCreateParams{ctx, payment},
		expectationOrigins: PaymentStorageMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up paymentStorage.Create return parameters for the expectation previously defined by the When method
func (e *PaymentStorageMockCreateExpectation) Then(s1 string, err error) *PaymentStorageMock {
	e.results = &PaymentStorageMockCreateResults{s1, err}
	return e.mock
}

// Times sets number of times paymentStorage.Create should be invoked
func (mmCreate *mPaymentStorageMockCreate) Times(n uint64) *mPaymentStorageMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of PaymentStorageMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mPaymentStorageMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements paymentStorage
func (mmCreate *PaymentStorageMock) Create(ctx context.Context, payment models.PaymentInfo) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, payment)
	}

	mm_params := PaymentStorageMockCreateParams{ctx, payment}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := PaymentStorageMockCreateParams{ctx, payment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("PaymentStorageMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.payment != nil && !minimock.Equal(*mm_want_ptrs.payment, mm_got.payment) {
				mmCreate.t.Errorf("PaymentStorageMock.Create got unexpected parameter payment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originPayment, *mm_want_ptrs.payment, mm_got.payment, minimock.Diff(*mm_want_ptrs.payment, mm_got.payment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("PaymentStorageMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the PaymentStorageMock.Create")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, payment)
	}
	mmCreate.t.Fatalf("Unexpected call to PaymentStorageMock.Create. %v %v", ctx, payment)
	return
}

// CreateAfterCounter returns a count of finished PaymentStorageMock.Create invocations
func (mmCreate *PaymentStorageMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of PaymentStorageMock.Create invocations
func (mmCreate *PaymentStorageMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to PaymentStorageMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mPaymentStorageMockCreate) Calls() []*PaymentStorageMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*PaymentStorageMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *PaymentStorageMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *PaymentStorageMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentStorageMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentStorageMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentStorageMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to PaymentStorageMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentStorageMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mPaymentStorageMockDelete struct {
	optional           bool
	mock               *PaymentStorageMock
	defaultExpectation *PaymentStorageMockDeleteExpectation
	expectations       []*PaymentStorageMockDeleteExpectation

	callArgs []*PaymentStorageMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentStorageMockDeleteExpectation specifies expectation struct of the paymentStorage.Delete
type PaymentStorageMockDeleteExpectation struct {
	mock               *PaymentStorageMock
	params             *PaymentStorageMockDeleteParams
	paramPtrs          *PaymentStorageMockDeleteParamPtrs
	expectationOrigins PaymentStorageMockDeleteExpectationOrigins
	results            *PaymentStorageMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// PaymentStorageMockDeleteParams contains parameters of the paymentStorage.Delete
type PaymentStorageMockDeleteParams struct {
	ctx  context.Context
	uuid string
}

// PaymentStorageMockDeleteParamPtrs contains pointers to parameters of the paymentStorage.Delete
type PaymentStorageMockDeleteParamPtrs struct {
	ctx  *context.Context
	uuid *string
}

// PaymentStorageMockDeleteResults contains results of the paymentStorage.Delete
type PaymentStorageMockDeleteResults struct {
	err error
}

// PaymentStorageMockDeleteOrigins contains origins of expectations of the paymentStorage.Delete
type PaymentStorageMockDeleteExpectationOrigins struct {
	origin     string
	originCtx  string
	originUuid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mPaymentStorageMockDelete) Optional() *mPaymentStorageMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for paymentStorage.Delete
func (mmDelete *mPaymentStorageMockDelete) Expect(ctx context.Context, uuid string) *mPaymentStorageMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PaymentStorageMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &PaymentStorageMockDeleteParams{ctx, uuid}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for paymentStorage.Delete
func (mmDelete *mPaymentStorageMockDelete) ExpectCtxParam1(ctx context.Context) *mPaymentStorageMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PaymentStorageMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PaymentStorageMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectUuidParam2 sets up expected param uuid for paymentStorage.Delete
func (mmDelete *mPaymentStorageMockDelete) ExpectUuidParam2(uuid string) *mPaymentStorageMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PaymentStorageMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &PaymentStorageMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.uuid = &uuid
	mmDelete.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the paymentStorage.Delete
func (mmDelete *mPaymentStorageMockDelete) Inspect(f func(ctx context.Context, uuid string)) *mPaymentStorageMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for PaymentStorageMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by paymentStorage.Delete
func (mmDelete *mPaymentStorageMockDelete) Return(err error) *PaymentStorageMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &PaymentStorageMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &PaymentStorageMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the paymentStorage.Delete method
func (mmDelete *mPaymentStorageMockDelete) Set(f func(ctx context.Context, uuid string) (err error)) *PaymentStorageMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the paymentStorage.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the paymentStorage.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the paymentStorage.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mPaymentStorageMockDelete) When(ctx context.Context, uuid string) *PaymentStorageMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("PaymentStorageMock.Delete mock is already set by Set")
	}

	expectation := &PaymentStorageMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &PaymentStorageMockDeleteParams{ctx, uuid},
		expectationOrigins: PaymentStorageMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up paymentStorage.Delete return parameters for the expectation previously defined by the When method
func (e *PaymentStorageMockDeleteExpectation) Then(err error) *PaymentStorageMock {
	e.results = &PaymentStorageMockDeleteResults{err}
	return e.mock
}

// Times sets number of times paymentStorage.Delete should be invoked
func (mmDelete *mPaymentStorageMockDelete) Times(n uint64) *mPaymentStorageMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of PaymentStorageMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mPaymentStorageMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements paymentStorage
func (mmDelete *PaymentStorageMock) Delete(ctx context.Context, uuid string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, uuid)
	}

	mm_params := PaymentStorageMockDeleteParams{ctx, uuid}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := PaymentStorageMockDeleteParams{ctx, uuid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("PaymentStorageMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uuid != nil && !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) {
				mmDelete.t.Errorf("PaymentStorageMock.Delete got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("PaymentStorageMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the PaymentStorageMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, uuid)
	}
	mmDelete.t.Fatalf("Unexpected call to PaymentStorageMock.Delete. %v %v", ctx, uuid)
	return
}

// DeleteAfterCounter returns a count of finished PaymentStorageMock.Delete invocations
func (mmDelete *PaymentStorageMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of PaymentStorageMock.Delete invocations
func (mmDelete *PaymentStorageMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to PaymentStorageMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mPaymentStorageMockDelete) Calls() []*PaymentStorageMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*PaymentStorageMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *PaymentStorageMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *PaymentStorageMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentStorageMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentStorageMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentStorageMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to PaymentStorageMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentStorageMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mPaymentStorageMockGetPaymentInfoByUUID struct {
	optional           bool
	mock               *PaymentStorageMock
	defaultExpectation *PaymentStorageMockGetPaymentInfoByUUIDExpectation
	expectations       []*PaymentStorageMockGetPaymentInfoByUUIDExpectation

	callArgs []*PaymentStorageMockGetPaymentInfoByUUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentStorageMockGetPaymentInfoByUUIDExpectation specifies expectation struct of the paymentStorage.GetPaymentInfoByUUID
type PaymentStorageMockGetPaymentInfoByUUIDExpectation struct {
	mock               *PaymentStorageMock
	params             *PaymentStorageMockGetPaymentInfoByUUIDParams
	paramPtrs          *PaymentStorageMockGetPaymentInfoByUUIDParamPtrs
	expectationOrigins PaymentStorageMockGetPaymentInfoByUUIDExpectationOrigins
	results            *PaymentStorageMockGetPaymentInfoByUUIDResults
	returnOrigin       string
	Counter            uint64
}

// PaymentStorageMockGetPaymentInfoByUUIDParams contains parameters of the paymentStorage.GetPaymentInfoByUUID
type PaymentStorageMockGetPaymentInfoByUUIDParams struct {
	ctx  context.Context
	uuid string
}

// PaymentStorageMockGetPaymentInfoByUUIDParamPtrs contains pointers to parameters of the paymentStorage.GetPaymentInfoByUUID
type PaymentStorageMockGetPaymentInfoByUUIDParamPtrs struct {
	ctx  *context.Context
	uuid *string
}

// PaymentStorageMockGetPaymentInfoByUUIDResults contains results of the paymentStorage.GetPaymentInfoByUUID
type PaymentStorageMockGetPaymentInfoByUUIDResults struct {
	p1  models.PaymentInfo
	err error
}

// PaymentStorageMockGetPaymentInfoByUUIDOrigins contains origins of expectations of the paymentStorage.GetPaymentInfoByUUID
type PaymentStorageMockGetPaymentInfoByUUIDExpectationOrigins struct {
	origin     string
	originCtx  string
	originUuid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) Optional() *mPaymentStorageMockGetPaymentInfoByUUID {
	mmGetPaymentInfoByUUID.optional = true
	return mmGetPaymentInfoByUUID
}

// Expect sets up expected params for paymentStorage.GetPaymentInfoByUUID
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) Expect(ctx context.Context, uuid string) *mPaymentStorageMockGetPaymentInfoByUUID {
	if mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUID != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by Set")
	}

	if mmGetPaymentInfoByUUID.defaultExpectation == nil {
		mmGetPaymentInfoByUUID.defaultExpectation = &PaymentStorageMockGetPaymentInfoByUUIDExpectation{}
	}

	if mmGetPaymentInfoByUUID.defaultExpectation.paramPtrs != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by ExpectParams functions")
	}

	mmGetPaymentInfoByUUID.defaultExpectation.params = &PaymentStorageMockGetPaymentInfoByUUIDParams{ctx, uuid}
	mmGetPaymentInfoByUUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPaymentInfoByUUID.expectations {
		if minimock.Equal(e.params, mmGetPaymentInfoByUUID.defaultExpectation.params) {
			mmGetPaymentInfoByUUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPaymentInfoByUUID.defaultExpectation.params)
		}
	}

	return mmGetPaymentInfoByUUID
}

// ExpectCtxParam1 sets up expected param ctx for paymentStorage.GetPaymentInfoByUUID
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) ExpectCtxParam1(ctx context.Context) *mPaymentStorageMockGetPaymentInfoByUUID {
	if mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUID != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by Set")
	}

	if mmGetPaymentInfoByUUID.defaultExpectation == nil {
		mmGetPaymentInfoByUUID.defaultExpectation = &PaymentStorageMockGetPaymentInfoByUUIDExpectation{}
	}

	if mmGetPaymentInfoByUUID.defaultExpectation.params != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by Expect")
	}

	if mmGetPaymentInfoByUUID.defaultExpectation.paramPtrs == nil {
		mmGetPaymentInfoByUUID.defaultExpectation.paramPtrs = &PaymentStorageMockGetPaymentInfoByUUIDParamPtrs{}
	}
	mmGetPaymentInfoByUUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPaymentInfoByUUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPaymentInfoByUUID
}

// ExpectUuidParam2 sets up expected param uuid for paymentStorage.GetPaymentInfoByUUID
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) ExpectUuidParam2(uuid string) *mPaymentStorageMockGetPaymentInfoByUUID {
	if mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUID != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by Set")
	}

	if mmGetPaymentInfoByUUID.defaultExpectation == nil {
		mmGetPaymentInfoByUUID.defaultExpectation = &PaymentStorageMockGetPaymentInfoByUUIDExpectation{}
	}

	if mmGetPaymentInfoByUUID.defaultExpectation.params != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by Expect")
	}

	if mmGetPaymentInfoByUUID.defaultExpectation.paramPtrs == nil {
		mmGetPaymentInfoByUUID.defaultExpectation.paramPtrs = &PaymentStorageMockGetPaymentInfoByUUIDParamPtrs{}
	}
	mmGetPaymentInfoByUUID.defaultExpectation.paramPtrs.uuid = &uuid
	mmGetPaymentInfoByUUID.defaultExpectation.expectationOrigins.originUuid = minimock.CallerInfo(1)

	return mmGetPaymentInfoByUUID
}

// Inspect accepts an inspector function that has same arguments as the paymentStorage.GetPaymentInfoByUUID
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) Inspect(f func(ctx context.Context, uuid string)) *mPaymentStorageMockGetPaymentInfoByUUID {
	if mmGetPaymentInfoByUUID.mock.inspectFuncGetPaymentInfoByUUID != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("Inspect function is already set for PaymentStorageMock.GetPaymentInfoByUUID")
	}

	mmGetPaymentInfoByUUID.mock.inspectFuncGetPaymentInfoByUUID = f

	return mmGetPaymentInfoByUUID
}

// Return sets up results that will be returned by paymentStorage.GetPaymentInfoByUUID
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) Return(p1 models.PaymentInfo, err error) *PaymentStorageMock {
	if mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUID != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by Set")
	}

	if mmGetPaymentInfoByUUID.defaultExpectation == nil {
		mmGetPaymentInfoByUUID.defaultExpectation = &PaymentStorageMockGetPaymentInfoByUUIDExpectation{mock: mmGetPaymentInfoByUUID.mock}
	}
	mmGetPaymentInfoByUUID.defaultExpectation.results = &PaymentStorageMockGetPaymentInfoByUUIDResults{p1, err}
	mmGetPaymentInfoByUUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPaymentInfoByUUID.mock
}

// Set uses given function f to mock the paymentStorage.GetPaymentInfoByUUID method
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) Set(f func(ctx context.Context, uuid string) (p1 models.PaymentInfo, err error)) *PaymentStorageMock {
	if mmGetPaymentInfoByUUID.defaultExpectation != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("Default expectation is already set for the paymentStorage.GetPaymentInfoByUUID method")
	}

	if len(mmGetPaymentInfoByUUID.expectations) > 0 {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("Some expectations are already set for the paymentStorage.GetPaymentInfoByUUID method")
	}

	mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUID = f
	mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUIDOrigin = minimock.CallerInfo(1)
	return mmGetPaymentInfoByUUID.mock
}

// When sets expectation for the paymentStorage.GetPaymentInfoByUUID which will trigger the result defined by the following
// Then helper
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) When(ctx context.Context, uuid string) *PaymentStorageMockGetPaymentInfoByUUIDExpectation {
	if mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUID != nil {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("PaymentStorageMock.GetPaymentInfoByUUID mock is already set by Set")
	}

	expectation := &PaymentStorageMockGetPaymentInfoByUUIDExpectation{
		mock:               mmGetPaymentInfoByUUID.mock,
		params:             &PaymentStorageMockGetPaymentInfoByUUIDParams{ctx, uuid},
		expectationOrigins: PaymentStorageMockGetPaymentInfoByUUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPaymentInfoByUUID.expectations = append(mmGetPaymentInfoByUUID.expectations, expectation)
	return expectation
}

// Then sets up paymentStorage.GetPaymentInfoByUUID return parameters for the expectation previously defined by the When method
func (e *PaymentStorageMockGetPaymentInfoByUUIDExpectation) Then(p1 models.PaymentInfo, err error) *PaymentStorageMock {
	e.results = &PaymentStorageMockGetPaymentInfoByUUIDResults{p1, err}
	return e.mock
}

// Times sets number of times paymentStorage.GetPaymentInfoByUUID should be invoked
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) Times(n uint64) *mPaymentStorageMockGetPaymentInfoByUUID {
	if n == 0 {
		mmGetPaymentInfoByUUID.mock.t.Fatalf("Times of PaymentStorageMock.GetPaymentInfoByUUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPaymentInfoByUUID.expectedInvocations, n)
	mmGetPaymentInfoByUUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPaymentInfoByUUID
}

func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) invocationsDone() bool {
	if len(mmGetPaymentInfoByUUID.expectations) == 0 && mmGetPaymentInfoByUUID.defaultExpectation == nil && mmGetPaymentInfoByUUID.mock.funcGetPaymentInfoByUUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPaymentInfoByUUID.mock.afterGetPaymentInfoByUUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPaymentInfoByUUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPaymentInfoByUUID implements paymentStorage
func (mmGetPaymentInfoByUUID *PaymentStorageMock) GetPaymentInfoByUUID(ctx context.Context, uuid string) (p1 models.PaymentInfo, err error) {
	mm_atomic.AddUint64(&mmGetPaymentInfoByUUID.beforeGetPaymentInfoByUUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPaymentInfoByUUID.afterGetPaymentInfoByUUIDCounter, 1)

	mmGetPaymentInfoByUUID.t.Helper()

	if mmGetPaymentInfoByUUID.inspectFuncGetPaymentInfoByUUID != nil {
		mmGetPaymentInfoByUUID.inspectFuncGetPaymentInfoByUUID(ctx, uuid)
	}

	mm_params := PaymentStorageMockGetPaymentInfoByUUIDParams{ctx, uuid}

	// Record call args
	mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.mutex.Lock()
	mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.callArgs = append(mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.callArgs, &mm_params)
	mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.mutex.Unlock()

	for _, e := range mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation.paramPtrs

		mm_got := PaymentStorageMockGetPaymentInfoByUUIDParams{ctx, uuid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPaymentInfoByUUID.t.Errorf("PaymentStorageMock.GetPaymentInfoByUUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uuid != nil && !minimock.Equal(*mm_want_ptrs.uuid, mm_got.uuid) {
				mmGetPaymentInfoByUUID.t.Errorf("PaymentStorageMock.GetPaymentInfoByUUID got unexpected parameter uuid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation.expectationOrigins.originUuid, *mm_want_ptrs.uuid, mm_got.uuid, minimock.Diff(*mm_want_ptrs.uuid, mm_got.uuid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPaymentInfoByUUID.t.Errorf("PaymentStorageMock.GetPaymentInfoByUUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPaymentInfoByUUID.GetPaymentInfoByUUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPaymentInfoByUUID.t.Fatal("No results are set for the PaymentStorageMock.GetPaymentInfoByUUID")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetPaymentInfoByUUID.funcGetPaymentInfoByUUID != nil {
		return mmGetPaymentInfoByUUID.funcGetPaymentInfoByUUID(ctx, uuid)
	}
	mmGetPaymentInfoByUUID.t.Fatalf("Unexpected call to PaymentStorageMock.GetPaymentInfoByUUID. %v %v", ctx, uuid)
	return
}

// GetPaymentInfoByUUIDAfterCounter returns a count of finished PaymentStorageMock.GetPaymentInfoByUUID invocations
func (mmGetPaymentInfoByUUID *PaymentStorageMock) GetPaymentInfoByUUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaymentInfoByUUID.afterGetPaymentInfoByUUIDCounter)
}

// GetPaymentInfoByUUIDBeforeCounter returns a count of PaymentStorageMock.GetPaymentInfoByUUID invocations
func (mmGetPaymentInfoByUUID *PaymentStorageMock) GetPaymentInfoByUUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaymentInfoByUUID.beforeGetPaymentInfoByUUIDCounter)
}

// Calls returns a list of arguments used in each call to PaymentStorageMock.GetPaymentInfoByUUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPaymentInfoByUUID *mPaymentStorageMockGetPaymentInfoByUUID) Calls() []*PaymentStorageMockGetPaymentInfoByUUIDParams {
	mmGetPaymentInfoByUUID.mutex.RLock()

	argCopy := make([]*PaymentStorageMockGetPaymentInfoByUUIDParams, len(mmGetPaymentInfoByUUID.callArgs))
	copy(argCopy, mmGetPaymentInfoByUUID.callArgs)

	mmGetPaymentInfoByUUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaymentInfoByUUIDDone returns true if the count of the GetPaymentInfoByUUID invocations corresponds
// the number of defined expectations
func (m *PaymentStorageMock) MinimockGetPaymentInfoByUUIDDone() bool {
	if m.GetPaymentInfoByUUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaymentInfoByUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaymentInfoByUUIDMock.invocationsDone()
}

// MinimockGetPaymentInfoByUUIDInspect logs each unmet expectation
func (m *PaymentStorageMock) MinimockGetPaymentInfoByUUIDInspect() {
	for _, e := range m.GetPaymentInfoByUUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentStorageMock.GetPaymentInfoByUUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaymentInfoByUUIDCounter := mm_atomic.LoadUint64(&m.afterGetPaymentInfoByUUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaymentInfoByUUIDMock.defaultExpectation != nil && afterGetPaymentInfoByUUIDCounter < 1 {
		if m.GetPaymentInfoByUUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentStorageMock.GetPaymentInfoByUUID at\n%s", m.GetPaymentInfoByUUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentStorageMock.GetPaymentInfoByUUID at\n%s with params: %#v", m.GetPaymentInfoByUUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPaymentInfoByUUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPaymentInfoByUUID != nil && afterGetPaymentInfoByUUIDCounter < 1 {
		m.t.Errorf("Expected call to PaymentStorageMock.GetPaymentInfoByUUID at\n%s", m.funcGetPaymentInfoByUUIDOrigin)
	}

	if !m.GetPaymentInfoByUUIDMock.invocationsDone() && afterGetPaymentInfoByUUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentStorageMock.GetPaymentInfoByUUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaymentInfoByUUIDMock.expectedInvocations), m.GetPaymentInfoByUUIDMock.expectedInvocationsOrigin, afterGetPaymentInfoByUUIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PaymentStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetPaymentInfoByUUIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PaymentStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PaymentStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetPaymentInfoByUUIDDone()
}
